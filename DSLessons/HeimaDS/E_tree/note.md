# 树



### 树的基本定义

树是由n（n>=1）个有限结点组成的一个具有层次关系的集合。结点之间存在一对多的关系

树具有以下特点：

- 每个结点有零个或多个子结点；
- 没有父结点的结点为根结点；
- 每一个非根结点只有一个父节点；
- 每个结点及其后代结点整体上可以看做是一棵树，成为当前结点的父结点的一个子树；



### 树的相关术语

**结点的度**：一个结点含有子树的个数称为该结点的度。

**叶结点**：度为0的结点称为叶结点，也可以叫做终端结点。

**分支结点**：度不为0的结点称为分支结点，也可以叫做非终端结点。

**结点的层次**：从根结点开始，根节点的层次为1，根的直接后继层次为2，以此类推。

**结点的层序编号**：将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。

**树的度**：树中所有结点的度的最大值。

**树的高度（深度）**：树中结点的最大层次。

**孩子结点**：一个结点的直接后继结点称为该结点的孩子结点。

**双亲结点**：一个结点的直接前驱结点称为该结点的双亲结点。

**兄弟结点**：同一双亲结点的孩子结点间互称兄弟结点。



### 二叉树的基本定义

二叉树是度不超过2的数，即数中每个结点最多只有两个子结点。

**满二叉树**：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。

**完全二叉树**：叶结点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树（相当于是从上到下，从左到右添加结点，放满一层，再继续下一层）。



### 二叉查找树的创建

##### 二叉查找树的结点类

| 类名     | Node\<T\>                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key, Value value, Node left, Node right)：构建Node对象 |
| 成员变量 | 1. public Key key：存储键<br />2. public Value value：存储值<br />3. public Node left：记录左子结点<br />4. public Node right：记录右子结点 |

##### 二叉查找树API设计

| 类名     | BinaryTree\<Key extends Comparable\<Key\>, Value\>           |
| -------- | ------------------------------------------------------------ |
| 构造方法 | BinaryTree()：创建BinaryTree对象                             |
| 成员变量 | 1. private Node root ：记录根结点<br />2. private int N：记录树中元素的个数 |
| 成员方法 | 1. public void put(Key key, Value value)：向树中插入一个键值对<br />2. private Node put(Node x, Key key, Value value)：给指定树x上，添加键一个键值对，并返回添加后的新树<br />3. public Value get(Key key)：根据key，从树中找出对应的值<br />4. private Value get(Node x, Key key)：从指定的树x中，找出key对应的值<br />5. public void delete(Key key)：根据key，删除树中对应的键值对<br />6. private Node delete(Node x, Key key)：删除指定树x上的键为key的键值对，并返回删除后的新树<br />7. public int size()：获取树中的元素 |

- 插入结点

  思路：

  1. 如果当前树中没有任何一个结点，则直接把新结点当做根结点使用
  2. 如果当前树不为空，则从根结点开始：
     1. 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；
     2. 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；
     3. 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。

- 查找结点

  思路：从根节点开始：

  1. 如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；
  2. 如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；
  3. 如果要查询的key等于当前结点的key，则树中返回当前结点的value。

- 删除结点

  思路：
  
  1. 找到被删除结点；
  2. 找到被删除结点右子树中的最小结点minNode
  3. 删除右子树中的最小结点
  4. 让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树
  5. 让被删除结点的父节点指向最小结点minNode

##### 二叉查找树获取最值

- 获取二叉树中的最大值

  思路：

- 获取二叉树中的最小值

  思路：



### 二叉树的遍历

由于二叉树具有树状结构，所以它没有办法从头开始依次向后遍历。对于一个二叉树而言，存在如何遍历，也就是按照什么样的搜索路径进行遍历的问题。

##### 二叉树的基础遍历

对于一个树而言，可以将其简化为由一个根结点、一个左子树和一个右子树组成，那么按照根结点什么时候被访问，可以将二叉树的遍历分为以下几种方式：

- 前序遍历：先访问根结点，然后再访问左子树，最后访问右子树。

  思路：

- 中序遍历：先访问左子树，中间访问根结点，最后访问右子树。

  思路：

  > 使用中序遍历得到的结果是升序的，从小到大，因为中序遍历总是先访问小的元素再访问大的元素。

- 后序遍历：先访问左子树，再访问右子树，最后访问根结点。

  思路：

##### 二叉树的层序遍历

所谓层序遍历，就是从根结点（第一层）开始，依次向下，获取每一层所有结点的值。

思路：

> 二叉树的不同遍历方式鉴戒的思想是不同的，对于基础遍历，是参考了深度优先，而对于层序遍历而言，则参考了广度优先的思想。



### 二叉树的最大深度问题

需求：给定一棵树，请计算树的最大深度（树的根结点到最远叶子结点的最长路径上的结点数）

思路：

1. 如果根结点为空，则最大深度为0
2. 计算左子树的最大深度
3. 计算右子树的最大深度
4. 当前树的最大深度为左子树和右子树最大深度的较大值加1





### 折纸问题

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。

需求：给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向（例如：N=1时，输出`down`；N=2时，输出`down down up`）

思路：

==待补充==

代码：

==待补充==





## 平衡树

对于二叉查找树而言，查找/插入/删除的时间复杂度在最好情况下是`log(n)`，因为每次和当前结点比较都能减少一半的问题规模，但在最坏情况下，当所有结点都没有右节点时，查找等操作的时间复杂度和线性表一样。导致时间复杂度不固定的原因在于，同样的数据元素，在以不同的顺序放入树时，产生的树不一样，深度也不一样。所以我们需要平衡树，来保证树，不受插入顺序的影响，让即使在最坏情况下，树的查找效率仍旧会很好。



### 2-3查找树

一棵2-3查找树要么为空，要么满足满足下面两个要求：

- 2-结点：含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
- 3-结点：含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。

#### 查找操作

思路：

#### 插入操作

思路：

#### 性质

1. 任意空链接到根结点的路径长度都是相等的。
2. 4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1。
3. 2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。



### 红黑树

我们前面介绍了2-3树，可以看到2-3树能保证在插入元素之后，树依然保持平衡状态，它的最坏情况下所有子结点都是2-结点，树的高度为lgN，相比于我们普通的二叉查找树，最坏情况下树的高度为N，确实保证了最坏情况下的时间复杂度，但是2-3树实现起来过于复杂，所以我们介绍一种2-3树思想的简单实现：红黑树。

红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树。

我们将树中的链接分为两种类型：

- 红链接：将两个2-结点连接起来构成一个3-结点；
- 黑链接：则是2-3树中的普通链接。

确切的说，我们将3-结点表示为由由一条左斜的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2-结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。

#### 红黑树的定义

红黑树是含有红黑链接并满足下列条件的二叉查找树： 

1. 红链接均为左链接；
2. 没有任何一个结点同时和两条红链接相连；
3. 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同；

#### 红黑树的查找

思路：

#### 红黑树的插入

思路：





### B树

B树作为2-3树的拓展

#### B树存储数据

可以保证平衡性