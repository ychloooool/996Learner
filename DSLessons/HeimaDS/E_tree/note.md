# 树



### 树的基本定义

树是由n（n>=1）个有限结点组成的一个具有层次关系的集合。结点之间存在一对多的关系

树具有以下特点：

- 每个结点有零个或多个子结点；
- 没有父结点的结点为根结点；
- 每一个非根结点只有一个父节点；
- 每个结点及其后代结点整体上可以看做是一棵树，成为当前结点的父结点的一个子树；



### 树的相关术语

**结点的度**：一个结点含有子树的个数称为该结点的度。

**叶结点**：度为0的结点称为叶结点，也可以叫做终端结点。

**分支结点**：度不为0的结点称为分支结点，也可以叫做非终端结点。

**结点的层次**：从根结点开始，根节点的层次为1，根的直接后继层次为2，以此类推。

**结点的层序编号**：将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。

**树的度**：树中所有结点的度的最大值。

**树的高度（深度）**：树中结点的最大层次。

**孩子结点**：一个结点的直接后继结点称为该结点的孩子结点。

**双亲结点**：一个结点的直接前驱结点称为该结点的双亲结点。

**兄弟结点**：同一双亲结点的孩子结点间互称兄弟结点。



### 二叉树的基本定义

二叉树是度不超过2的数，即数中每个结点最多只有两个子结点。

**满二叉树**：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。

**完全二叉树**：叶结点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树（相当于是从上到下，从左到右添加结点，放满一层，再继续下一层）。



### 二叉查找树的创建

##### 二叉查找树的结点类

| 类名     | Node\<T\>                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key, Value value, Node left, Node right)：构建Node对象 |
| 成员变量 | 1. public Key key：存储键<br />2. public Value value：存储值<br />3. public Node left：记录左子结点<br />4. public Node right：记录右子结点 |

##### 二叉查找树API设计

| 类名     | BinaryTree\<Key extends Comparable\<Key\>, Value\>           |
| -------- | ------------------------------------------------------------ |
| 构造方法 | BinaryTree()：创建BinaryTree对象                             |
| 成员变量 | 1. private Node root ：记录根结点<br />2. private int N：记录树中元素的个数 |
| 成员方法 | 1. public void put(Key key, Value value)：向树中插入一个键值对<br />2. private Node put(Node x, Key key, Value value)：给指定树x上，添加键一个键值对，并返回添加后的新树<br />3. public Value get(Key key)：根据key，从树中找出对应的值<br />4. private Value get(Node x, Key key)：从指定的树x中，找出key对应的值<br />5. public void delete(Key key)：根据key，删除树中对应的键值对<br />6. private Node delete(Node x, Key key)：删除指定树x上的键为key的键值对，并返回删除后的新树<br />7. public int size()：获取树中的元素 |

- 插入结点

  思路：

  1. 如果当前树中没有任何一个结点，则直接把新结点当做根结点使用
  2. 如果当前树不为空，则从根结点开始：
     1. 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；
     2. 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；
     3. 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。

- 查找结点

  思路：从根节点开始：

  1. 如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；
  2. 如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；
  3. 如果要查询的key等于当前结点的key，则树中返回当前结点的value。

- 删除结点

  思路：
  
  1. 找到被删除结点；
  2. 找到被删除结点右子树中的最小结点minNode
  3. 删除右子树中的最小结点
  4. 让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树
  5. 让被删除结点的父节点指向最小结点minNode

##### 二叉查找树获取最值

- 获取二叉树中的最大值

  思路：

- 获取二叉树中的最小值

  思路：



### 二叉树的遍历

由于二叉树具有树状结构，所以它没有办法从头开始依次向后遍历。对于一个二叉树而言，存在如何遍历，也就是按照什么样的搜索路径进行遍历的问题。

##### 二叉树的基础遍历

对于一个树而言，可以将其简化为由一个根结点、一个左子树和一个右子树组成，那么按照根结点什么时候被访问，可以将二叉树的遍历分为以下几种方式：

- 前序遍历：先访问根结点，然后再访问左子树，最后访问右子树。

  思路：

- 中序遍历：先访问左子树，中间访问根结点，最后访问右子树。

  思路：

  > 使用中序遍历得到的结果是升序的，从小到大，因为中序遍历总是先访问小的元素再访问大的元素。

- 后序遍历：先访问左子树，再访问右子树，最后访问根结点。

  思路：

##### 二叉树的层序遍历

所谓层序遍历，就是从根结点（第一层）开始，依次向下，获取每一层所有结点的值。

思路：

> 二叉树的不同遍历方式鉴戒的思想是不同的，对于基础遍历，是参考了深度优先，而对于层序遍历而言，则参考了广度优先的思想。



### 二叉树的最大深度问题

需求：给定一棵树，请计算树的最大深度（树的根结点到最远叶子结点的最长路径上的结点数）

思路：

1. 如果根结点为空，则最大深度为0
2. 计算左子树的最大深度
3. 计算右子树的最大深度
4. 当前树的最大深度为左子树和右子树最大深度的较大值加1





### 折纸问题

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。

需求：给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向（例如：N=1时，输出`down`；N=2时，输出`down down up`）

思路：



代码：

