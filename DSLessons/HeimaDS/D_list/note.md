# 线性表（List）



#### 线性表概念

线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。



#### 线性表的特征

数据元素之间具有一种“一对一”的逻辑关系。

- 线性表的第一个数据元素没有前驱元素，该元素被称为头结点。
- 线性表的最后一个数据元素没有后继，这个数据元素被称为尾结点。
- 除了第一个和最后一个数据元素之外，其他数据元素有且仅有一个前驱元素和一个后继元素。

> 前驱元素：若A元素在B元素的前面，则称A为B的前驱元素。
>
> 后继元素：若B元素在A元素的后面，则称B为A的后继元素。



#### 线性表的分类

线性表中数据存储的方式可以是顺序存储，也可以是链式存储。

按照数据的存储方式不同，可以把线性表分为顺序表和链表





## 顺序表（SequenceList）



#### 顺序表概念

顺序表是在计算机内存中以数组的形式保存的线性表。线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素。该特性使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，以此反映了数据元素在逻辑上的相邻关系。



#### 顺序表实现API

| 类名     | SequenceList\<T\>                                            |
| -------- | ------------------------------------------------------------ |
| 构造方法 | SequenceList(int capacity)：创建容量为capacity的SequenceList对象 |
| 成员变量 | 1. public void clear()：清空线性表内容<br />2. public boolean isEmpty()：判断线性表是否为空<br />3. public int length()：获取线性表中元素的个数<br />4. public T get(int i)：读取并返回线性表中的第i个元素的值<br />5. public void insert(int i, T t)：在线性表的第i个元素之前插入一个值为t的数据元素<br />6. public void insert(T t)：向线性表中添加一个元素<br />7. public T remove(int i)：删除并返回线性表中第i个数据元素<br />8. public int indexOf(T t)：返回线性表中首次出现的指定的数据元素的位序号，不存在则返回-1 |
| 成员方法 | 1. private T[] elements：存储元素的数据<br />2. private int N：当前线性表的长度 |



#### 顺序表的遍历

在Java中，遍历集合的方式一般是使用foreach循环。

支持foreach循环所需要的步骤：

1. 需要类实现Iterable接口，重写iterator方法；
2. 在类内部提供一个内部类Iterator，实现iterator接口，重写hasNext方法和next方法；

```
例子：详见SequenceList实现
```



#### 顺序表的扩容

容器在设计时，要考虑其容量的伸缩性。对于顺序表的扩容，其实就是对其内部维护的数组大小进行改变。

需要改变顺序表容量的时机：

- 添加元素时，元素大于容量，扩容一倍；
- 移除元素时，元素小于容量的1/4，缩容一半；



#### 顺序表的时间复杂度

获取元素时，不论数据元素量多大，直接通过元素的下标就可以访问对应元素，所以时间复杂度为`O(1)`；

添加/删除元素时，必须将目标位置后面的元素都进行一次移动，随着数量增大，移动元素线性增长，所以时间复杂度为`O(n)`；

当涉及到容器扩容时，需要申请新的内存，并复制元素，导致耗时会增加。当元素越多时，耗时增加就越明显。所以插入/删除元素的时间复杂度不是线性的。



#### Java中的顺序表实现

ArrayList类是Java集合框架中最常用的顺序表，底层使用数组实现，同样提供了增删改查、扩容、遍历等功能。

ArrayList常用方法：==待补充==

| 方法 | 作用 |
| :--- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |





## 链表（LinkedList）



#### 链表概念

顺序表的查询很快，增删的效率比较低，原因在于其通过数组来保存数据。而链表是一种物理存储单元上非连续、非顺序的存储结构。其数据元素的逻辑顺序是通过链表中的指针链接次序体现的。链表由一系列的结点组成，结点可以在运行时动态生成





#### 单向链表

##### 概念

单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其他后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。

##### 结点类API设计

| 类名     | Node\<T\>                                       |
| -------- | ----------------------------------------------- |
| 构造方法 | Node(T t, Node next)：构建Node对象              |
| 成员变量 | T item：存储元素<br />Node next：指向下一个结点 |

```java
private class Node<T> {

    public T item;
    public Node<T> next;

    public Node(T item, Node<T> next) {
        this.item = item;
        this.next = next;
    }

}
```

##### API设计

| 类名       | LinkList\<T\>                                                |
| ---------- | ------------------------------------------------------------ |
| 构造方法   | LinkList()：创建LinkList对象                                 |
| 成员变量   | 1. public void clear()：清空线性表内容<br />2. public boolean isEmpty()：判断线性表是否为空<br />3. public int length()：获取线性表中元素的个数<br />4. public T get(int i)：读取并返回线性表中的第i个元素的值<br />5. public void insert(int i, T t)：在线性表的第i个元素之前插入一个值为t的数据元素<br />6. public void insert(T t)：向线性表中添加一个元素<br />7. public T remove(int i)：删除并返回线性表中第i个数据元素<br />8. public int indexOf(T t)：返回线性表中首次出现的指定的数据元素的位序号，不存在则返回-1 |
| 成员内部类 | private class Node\<T\>：结点类                              |
| 成员方法   | 1. private Node head：记录首结点<br />2. private int N：记录链表的长度 |





#### 双向链表

##### 概念

双向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。链表的尾结点的数据域不存储数据，指向后继结点的指针域值为null，指向前驱结点的指针域指向最后一个真正存储数据的结点。

##### 结点类API设计

| 类名     | Node\<T\>                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(T t, Node pre, Node next)：构建Node对象                 |
| 成员变量 | T item：存储元素<br />Node next：指向下一个结点<br />Node pre：指向上一个结点 |

##### API设计

| 类名       | TwoWayLinkList\<T\>                                          |
| ---------- | :----------------------------------------------------------- |
| 构造方法   | TwoWayLinkList()：创建LinkList对象                           |
| 成员变量   | 1. public void clear()：清空线性表内容<br />2. public boolean isEmpty()：判断线性表是否为空<br />3. public int length()：获取线性表中元素的个数<br />4. public T get(int i)：读取并返回线性表中的第i个元素的值<br />5. public void insert(int i, T t)：在线性表的第i个元素之前插入一个值为t的数据元素<br />6. public void insert(T t)：向线性表中添加一个元素<br />7. public T remove(int i)：删除并返回线性表中第i个数据元素<br />8. public int indexOf(T t)：返回线性表中首次出现的指定的数据元素的位序号，不存在则返回-1<br />9. public T getFirst()：获取第一个元素<br />10. public T getLast()：获取最后一个元素 |
| 成员内部类 | private class Node\<T\>：结点类                              |
| 成员方法   | 1. private Node head：记录首结点<br />2. private Node last：记录尾结点<br />3. private int N：记录链表的长度 |



#### Java中的链表实现

LinkedList类是Java集合框架中最常用的链表表，底层使用双向链表实现，同样提供了增删改查、扩容、遍历等功能。

LinkedList常用方法：==待补充==

| 方法 | 作用 |
| :--- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |



#### 链表的时间复杂度

对于链表而言，获取/插入/删除元素都需要遍历链表找到对应元素，所以时间复杂度为`O(n)`。

相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先制定存储空间大小，或者在存储过程中涉及到扩容等操作，同时它并没有涉及元素的交换。

总的来说，相较于顺序表，链表的查询操作性能会比较低，但增删操作性能优于顺序表。因此，如果程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。



#### 链表反转

```java
// 单链表反转
public void reverse() {
    if (!isEmpty()) {
        reverseNode(this.head.next);
    }
}

// 反转单个结点
private Node reverseNode(Node current) {
    if (current.next == null) {
        // 递归基
        this.head.next = current; // 将头结点指向尾部
        return current; // 返回当前结点
    } else {
        Node previous = reverseNode(current.next); // 将后序结点反转，并得到反转后的最后一个元素
        previous.next = current; // 将最后一个元素的下一个设置为现有结点
        current.next = null; // 将当前最后元素的下一个设置为空
        return current; // 返回当前结点
    }
}
```

> 递归的核心在于关联父问题和子问题，在处理父问题时，要假设子问题已经得到了解决，利用子问题的结果，借此得到父问题的结果。
>
> 链表反转代码中，reverseNode返回参数存在的意义就在于为父问题提供子问题的解决结果。
>
> 如果在递归过程中，不去执行设置当前最后元素的下一个为空
>
> ```java
> current.next = null;
> ```
>
> 则会出现最后一个元素又指向了前一个元素，即循环引用的产生。



#### 快慢指针

##### 中间值问题







